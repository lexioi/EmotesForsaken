-- === НАСТРОЙКА КЛЮЧА ===
local validKey = "Thanks4Join "
local linkToCopy = "https://discord.gg/jCrnRkuN" -- замените на нужную ссылку

-- === СОЗДАНИЕ GUI ДЛЯ КЛЮЧА ===
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local keyGui = Instance.new("ScreenGui")
keyGui.Name = "KeySystemGui"
keyGui.ResetOnSpawn = false
keyGui.Parent = playerGui

local keyFrame = Instance.new("Frame")
keyFrame.Size = UDim2.new(0, 300, 0, 200)
keyFrame.Position = UDim2.new(0.5, -150, 0.5, -100)
keyFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
keyFrame.BackgroundTransparency = 0.5 -- прозрачность 0.4-0.6
keyFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
keyFrame.Parent = keyGui

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 50)
title.Position = UDim2.new(0, 0, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Key System"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.SourceSansBold
title.TextSize = 24
title.Parent = keyFrame

local textBox = Instance.new("TextBox")
textBox.Size = UDim2.new(0.8, 0, 0, 40)
textBox.Position = UDim2.new(0.1, 0, 0.35, 0)
textBox.PlaceholderText = "Enter your key..."
textBox.Text = ""
textBox.TextScaled = true
textBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
textBox.BorderColor3 = Color3.fromRGB(255, 255, 255)
textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
textBox.Parent = keyFrame

local copyButton = Instance.new("TextButton")
copyButton.Size = UDim2.new(0.45, -5, 0, 40)
copyButton.Position = UDim2.new(0.05, 0, 0.65, 0)
copyButton.Text = "Copy Link"
copyButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
copyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
copyButton.Font = Enum.Font.SourceSansBold
copyButton.TextSize = 18
copyButton.Parent = keyFrame

local submitButton = Instance.new("TextButton")
submitButton.Size = UDim2.new(0.45, -5, 0, 40)
submitButton.Position = UDim2.new(0.5, 5, 0.65, 0)
submitButton.Text = "Submit Key"
submitButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
submitButton.TextColor3 = Color3.fromRGB(255, 255, 255)
submitButton.Font = Enum.Font.SourceSansBold
submitButton.TextSize = 18
submitButton.Parent = keyFrame

-- Текст "Скопировано!" под кнопкой Copy Link (изначально скрыт)
local copiedLabel = Instance.new("TextLabel")
copiedLabel.Size = UDim2.new(0.45, -5, 0, 20)
copiedLabel.Position = UDim2.new(0.05, 0, 0.75, 0)
copiedLabel.BackgroundTransparency = 1
copiedLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
copiedLabel.Font = Enum.Font.SourceSansBold
copiedLabel.TextSize = 16
copiedLabel.Text = ""
copiedLabel.TextTransparency = 1 -- изначально скрыт
copiedLabel.Parent = keyFrame

-- === ФУНКЦИЯ КОПИРОВАНИЯ ССЫЛКИ ===
copyButton.Activated:Connect(function()
	setclipboard(linkToCopy)
	
	-- Показываем "Скопировано!" на 2 секунды
	copiedLabel.Text = "Copied!"
	copiedLabel.TextTransparency = 0
	wait(2)
	copiedLabel.TextTransparency = 1
end)

-- === ВСТАВЬ СЮДА КОД scriptl.txt ===
local lexioiScript = [[
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

-- Переменные игрока и персонажа (будут устанавливаться динамически)
local player = Players.LocalPlayer
print("DEBUG: LocalPlayer:", player.Name)

local character: Model? = nil
local humanoid: Humanoid? = nil
local originalJumpPower = 50

-- Ресурсы
local assetsFolder = ReplicatedStorage:WaitForChild("Assets")
local emotesFolder = assetsFolder:WaitForChild("Emotes")
-- Папка Animations больше не используется для загрузки ModuleScript'ов, но может существовать
local animationsFolder = assetsFolder:FindFirstChild("Animations") or Instance.new("Folder", assetsFolder)
animationsFolder.Name = "Animations" -- Создаем для консистентности, но она не будет сканироваться на ModuleScripts

-- ВСТРОЕННЫЕ ДАННЫЕ АНИМАЦИЙ УБИЙЦ
-- Все предоставленные вами анимации собраны здесь в одну таблицу.
local allKillerAnimations = {
    -- Анимации 1x1x1x1
    ["1x1x1x1"] = { -- Это будет отображаться как название кнопки в меню
        ZombieAnimations = {
            Idle = "rbxassetid://138465378316476";
            Walk = "rbxassetid://127848783748209";
            Run = "rbxassetid://72722119435580";
            Attack = "rbxassetid://81362825527808";
            Summon = "rbxassetid://75804462760596";
        };
        Animations = {
            Idle = "rbxassetid://138754221537146";
            Walk = "rbxassetid://109130982296927";
            Run = "rbxassetid://106485518413331";
            Introduction = {
                KillerRig = "rbxassetid://90184955335084";
                CameraRig = "rbxassetid://81326704545708"; -- Игнорируется
            };
            Execution = {
                KillerRig = "rbxassetid://93368339913846";
                PlayerRig = "rbxassetid://116471413261624";
            };
            ExecutionShedletsky = {
                KillerRig = "rbxassetid://123924093489218";
                PlayerRig = "rbxassetid://116039506373774";
            };
            BetterIdle = "rbxassetid://138754221537146";
            BetterWalk = "rbxassetid://131235528875091";
            BetterRun = "rbxassetid://89252407304675";
            Slash = "rbxassetid://83829782357897";
            Entanglement = "rbxassetid://119181003138006";
            UnstableEye = "rbxassetid://119429069577280";
            RejuvenateTheRotten = "rbxassetid://116996902830888";
            MassInfection = "rbxassetid://131430497821198";
            Stunned = {
                Start = "rbxassetid://96642629473615";
                Loop = "rbxassetid://131392439047269";
                End = "rbxassetid://121164654140845";
            };
            Victory = {
                KillerRig = "rbxassetid://137889266669216";
                CameraRig = "rbxassetid://129809576292762"; -- Игнорируется
                ShedletskyRig = "rbxassetid://121740536645205";
            };
        };
    },
    -- Анимации c00lkidd
    ["c00lkidd"] = {
        PizzaDeliveryAnimations = {
            Summoned = "rbxassetid://18886065814";
            Idle = "rbxassetid://18886066950";
            Walk = "rbxassetid://18886064499";
            Hit = "rbxassetid://18886068630";
        };
        Animations = {
            Idle = "rbxassetid://18885903667";
            Walk = "rbxassetid://18885906143";
            Run = "rbxassetid://96571077893813";
            InjuredIdle = "rbxassetid://18885903667";
            InjuredWalk = "rbxassetid://18885906143";
            InjuredRun = "rbxassetid://96571077893813";
            Stunned = {
                Start = "rbxassetid://109869078763813";
                Loop = "rbxassetid://125337218572338";
                End = "rbxassetid://83635673319417";
            };
            Introduction = {
                KillerRig = "rbxassetid://18924919303";
                CameraRig = "rbxassetid://18925097303"; -- Игнорируется
            };
            Victory = {
                KillerRig = "rbxassetid://108042935463999";
                KillerRigLoop = "rbxassetid://86524030996609";
                CameraRig = "rbxassetid://78439581321137"; -- Игнорируется
            };
            Execution = {
                KillerRig = "rbxassetid://89669118763885";
                PlayerRig = "rbxassetid://78051806190478";
            };
            Execution007n7 = {
                KillerRig = "rbxassetid://133688616073016";
                PlayerRig = "rbxassetid://132293609857524";
            };
            Attack = "rbxassetid://18885909645";
            CorruptNature = "rbxassetid://18885919947";
            SummonPizzaDelivery = "rbxassetid://18885915433";
            WalkspeedOverrideStart = "rbxassetid://98456918873918";
            WalkspeedOverrideLoop = "rbxassetid://106776364623742";
            WalkspeedOverrideHit = "rbxassetid://18885937766";
            WalkspeedOverrideMiss = "rbxassetid://18885940850";
        };
    },
    -- Анимации Noli
    ["Noli"] = {
        Animations = {
            Idle = "rbxassetid://83465205704188";
            Walk = "rbxassetid://109700476007435";
            Run = "rbxassetid://117451341682452";
            InjuredIdle = "rbxassetid://83465205704188";
            InjuredWalk = "rbxassetid://109700476007435";
            InjuredRun = "rbxassetid://117451341682452";
            Stab = "rbxassetid://109230267448394";
            Victory = {
                KillerRig = "rbxassetid://89207009102595";
                CameraRig = "rbxassetid://92599409662127"; -- Игнорируется
            };
            VoidRush = {
                StartCharge = "rbxassetid://91758760621955";
                LoopCharge = "rbxassetid://93841120533318";
                CancelCharge = "rbxassetid://91758760621955";
                StartDashInit = "rbxassetid://139835501033932";
                LoopDashInit = "rbxassetid://126896426760253";
                StartDashCombo = "rbxassetid://114356208094580";
                LoopDashCombo = "rbxassetid://135884061951801";
                EndDash = "rbxassetid://139321362207112";
                EndDashCrashed = "rbxassetid://94039555054855";
                EndDashNonChar = "rbxassetid://94039555054855";
                WeakHit = "rbxassetid://92243093913547";
                CutsceneKillerRig = "rbxassetid://81533966558979";
            };
            VoidRushVictimRig = "rbxassetid://134053005930385";
            NovaThrow = "rbxassetid://107339108383093";
            NovaDet = "rbxassetid://125504560920616";
            ObservantStart = "rbxassetid://113357690193035";
            ObservantLoop = "rbxassetid://104744456957363";
            ObservantTeleport = "rbxassetid://140042539182927";
            Hallucination = "rbxassetid://140042539182927";
            Introduction = {
                KillerRig = "rbxassetid://82002727792391";
                CameraRig = "rbxassetid://140061272138793"; -- Игнорируется
            };
            Execution = {
                KillerRig = "rbxassetid://129491851057694";
                PlayerRig = "rbxassetid://116544958644813";
                PlayerCFrameOffset = CFrame.new(0, 0, -6); -- Игнорируется
            };
            Stunned = {
                Start = "rbxassetid://128923537868786";
                Loop = "rbxassetid://122580527125278";
                End = "rbxassetid://99164529472582";
            };
        };
    },
    -- Jason и JohnDoe пока пустые, как вы и просили
    ["Jason"] = { Animations = {} },
    ["JohnDoe"] = { Animations = {} },
}


-- Управление состоянием
local activeEmotes: {[Humanoid]: {animationTrack: AnimationTrack?, sound: Sound?, stoppedConnection: RBXScriptConnection?}} = {}
local isMovementDisabled: boolean = false
local currentCategory = "Emotes" -- Категория по умолчанию
local currentSubCategory = nil -- Текущая выбранная подкатегория внутри "Animations"

-- Хранит все загруженные конфигурации и кнопки по категориям
local categoryData = {
    Emotes = {
        folder = emotesFolder,
        configs = {},
        buttons = {},
        scrollingFrame = nil,
        uiListLayout = nil,
        buttonNameCache = {}
    },
    Animations = {
        folder = nil, -- Больше не сканируем папку, данные хардкодируются
        subCategories = {}, -- Теперь здесь будут данные из allKillerAnimations
        buttons = {},
        scrollingFrame = nil,
        uiListLayout = nil,
        buttonNameCache = {},
        currentSubCategoryFrame = nil,
        currentSubCategoryLayout = nil,
    },
}

-- GUI Creation
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "EmoteGui"
screenGui.Parent = player:WaitForChild("PlayerGui")
screenGui.ResetOnSpawn = false

local openButton = Instance.new("TextButton")
openButton.Name = "OpenButton"
openButton.Parent = screenGui
openButton.Size = UDim2.new(0, 150, 0, 50)
openButton.Position = UDim2.new(0.5, -75, 0.8, 0)
openButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
openButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
openButton.TextColor3 = Color3.fromRGB(255, 255, 255)
openButton.Text = "Open Menu"
openButton.Font = Enum.Font.SourceSansBold
openButton.TextSize = 20
openButton.Active = true
openButton.Draggable = true

local mainFrame = Instance.new("Frame")
mainFrame.Name = "EmoteMenu"
mainFrame.Parent = screenGui
mainFrame.Size = UDim2.new(0, 400, 0, 350)
mainFrame.Position = UDim2.new(0.5, -200, 0.5, -175)
mainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
mainFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
mainFrame.Visible = false
mainFrame.Active = true
mainFrame.Draggable = true

-- Контейнер кнопок категорий
local categoryButtonsFrame = Instance.new("Frame")
categoryButtonsFrame.Name = "CategoryButtons"
categoryButtonsFrame.Parent = mainFrame
categoryButtonsFrame.Size = UDim2.new(1, 0, 0, 40)
categoryButtonsFrame.Position = UDim2.new(0, 0, 0, 0)
categoryButtonsFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
categoryButtonsFrame.BorderSizePixel = 0

local uiListLayoutCategories = Instance.new("UIListLayout")
uiListLayoutCategories.Parent = categoryButtonsFrame
uiListLayoutCategories.FillDirection = Enum.FillDirection.Horizontal
uiListLayoutCategories.HorizontalAlignment = Enum.HorizontalAlignment.Center
uiListLayoutCategories.VerticalAlignment = Enum.VerticalAlignment.Center
uiListLayoutCategories.Padding = UDim.new(0, 5)
uiListLayoutCategories.SortOrder = Enum.SortOrder.LayoutOrder

-- Элементы поиска
local searchButton = Instance.new("TextButton")
searchButton.Name = "SearchButton"
searchButton.Parent = mainFrame
searchButton.Size = UDim2.new(0, 30, 0, 30)
searchButton.Position = UDim2.new(1, -35, 0, 45)
searchButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
searchButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
searchButton.TextColor3 = Color3.fromRGB(255, 255, 255)
searchButton.Text = "🔍"
searchButton.Font = Enum.Font.SourceSansBold
searchButton.TextSize = 20
searchButton.ZIndex = 2

local searchTextBox = Instance.new("TextBox")
searchTextBox.Name = "SearchTextBox"
searchTextBox.Parent = mainFrame
searchTextBox.Size = UDim2.new(1, -40, 0, 30)
searchTextBox.Position = UDim2.new(0, 5, 0, 85)
searchTextBox.PlaceholderText = "Search in the current category..."
searchTextBox.TextScaled = true
searchTextBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
searchTextBox.BorderColor3 = Color3.fromRGB(255, 255, 255)
searchTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
searchTextBox.Visible = false
searchTextBox.ClearTextOnFocus = false
searchTextBox.ZIndex = 2

--- Основные функции ---

-- Функция для сброса движения игрока к значениям по умолчанию
local function resetPlayerMovement()
    if humanoid and isMovementDisabled then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = originalJumpPower
        isMovementDisabled = false
    end
end

-- Функция для остановки конкретной эмоции для данного гуманоида (используется только для локального игрока сейчас)
local function stopEmoteForHumanoid(targetHumanoid: Humanoid)
    local emoteData = activeEmotes[targetHumanoid]
    if emoteData then
        if emoteData.animationTrack then
            emoteData.animationTrack:Stop()
            if emoteData.stoppedConnection then
                emoteData.stoppedConnection:Disconnect()
                emoteData.stoppedConnection = nil
            end
        end
        if emoteData.sound then
            emoteData.sound:Stop()
            emoteData.sound:Destroy() -- Удаляем экземпляр звука
        end
        activeEmotes[targetHumanoid] = nil
    end
end

-- Функция для остановки всех воспроизводимых в данный момент эмоций и сброса состояния игрока
local function stopAllEmotes()
    if humanoid then
        stopEmoteForHumanoid(humanoid)
    end
    activeEmotes = {}
    resetPlayerMovement()
end

-- Локальная функция для воспроизведения анимации (только на стороне клиента для мгновенной обратной связи)
-- Включает поддержку для таблиц AssetID (случайный выбор) и SFX
local function playLocalAnimation(targetHumanoid: Humanoid, animationIdOrTable: any, sfxIdOrTable: any, sfxProperties: {Looped: boolean?}, characterModel: Model)
    stopEmoteForHumanoid(targetHumanoid)

    local animationIdToPlay: string
    if type(animationIdOrTable) == "table" then
        if #animationIdOrTable > 0 then
            animationIdToPlay = animationIdOrTable[math.random(1, #animationIdOrTable)]
            print("DEBUG: Случайно выбранный AnimationId (из таблицы):", animationIdToPlay)
        else
            warn("DEBUG: animationIdOrTable является пустой таблицей. Невозможно воспроизвести анимацию.")
            return
        end
    elseif type(animationIdOrTable) == "string" then
        animationIdToPlay = animationIdOrTable
        print("DEBUG: Используем AnimationId (из строки):", animationIdToPlay)
    else
        warn("DEBUG: Недопустимый тип для animationIdOrTable. Ожидалась строка или таблица, получено", type(animationIdOrTable))
        return
    end

    local animation = Instance.new("Animation")
    animation.AnimationId = animationIdToPlay
    local animationTrack = targetHumanoid:LoadAnimation(animation)
    animationTrack:Play()

    activeEmotes[targetHumanoid] = {animationTrack = animationTrack}

    local soundAttachmentPart = nil
    if sfxIdOrTable and characterModel then
        print("DEBUG: Пытаемся найти часть для прикрепления звука для characterModel:", characterModel.Name)

        local chosenSfxId: string
        if type(sfxIdOrTable) == "table" then
            if #sfxIdOrTable > 0 then
                chosenSfxId = sfxIdOrTable[math.random(1, #sfxIdOrTable)]
                print("DEBUG: Случайно выбранный SFXId (из таблицы):", chosenSfxId)
            else
                warn("DEBUG: sfxIdOrTable является пустой таблицей. Звук не будет воспроизводиться.")
            end
        elseif type(sfxIdOrTable) == "string" then
            chosenSfxId = sfxIdOrTable
            print("DEBUG: Используем SFXId (из строки):", chosenSfxId)
        else
            warn("DEBUG: Недопустимый тип для sfxIdOrTable. Ожидалась строка или таблица, получено", type(sfxIdOrTable))
        end

        if chosenSfxId then
            local success, rootPartResult = pcall(function()
                return characterModel:WaitForChild("HumanoidRootPart", 10)
            end)

            if success and rootPartResult then
                soundAttachmentPart = rootPartResult
                print("DEBUG: HumanoidRootPart успешно найдена для", characterModel.Name)
            else
                warn(string.format("DEBUG: HumanoidRootPart НЕ найдена для модели '%s' в течение 10 секунд! Пытаемся использовать альтернативу (UpperTorso/Torso).", characterModel.Name))
                soundAttachmentPart = characterModel:FindFirstChild("UpperTorso") or characterModel:FindFirstChild("Torso")
                if soundAttachmentPart then
                    print(string.format("DEBUG: Успешно найдена альтернативная часть для прикрепления звука (%s) для %s.", soundAttachmentPart.Name, characterModel.Name))
                else
                    warn(string.format("DEBUG: Ни HumanoidRootPart, ни UpperTorso, ни Torso не найдены для модели '%s'! Звук не будет воспроизводиться.", characterModel.Name))
                end
            end
        end

        if chosenSfxId and soundAttachmentPart then
            local sound = Instance.new("Sound")
            sound.SoundId = chosenSfxId
            sound.Parent = soundAttachmentPart
            if sfxProperties and sfxProperties.Looped then
                sound.Looped = true
                local soundStoppedConnection
                soundStoppedConnection = animationTrack.Stopped:Connect(function()
                    if sound and sound.IsPlaying then
                        sound:Stop()
                    end
                    if soundStoppedConnection then
                        soundStoppedConnection:Disconnect()
                    end
                end)
            end
            sound:Play()
            activeEmotes[targetHumanoid].sound = sound
        elseif chosenSfxId then
            warn(string.format("DEBUG: Звук для анимации '%s' не мог быть воспроизведен, потому что не найдена допустимая часть для прикрепления.", animationIdToPlay))
        end
    elseif sfxIdOrTable and not characterModel then
        warn("DEBUG: characterModel = NIL при попытке воспроизвести звук для анимации:", animationIdToPlay)
    end

    activeEmotes[targetHumanoid].stoppedConnection = animationTrack.Stopped:Connect(function()
        task.wait()
        if activeEmotes[targetHumanoid] and activeEmotes[targetHumanoid].animationTrack == animationTrack then
            stopEmoteForHumanoid(targetHumanoid)
        end
    end)
end


-- Функция для обновления размера холста ScrollingFrame для данной категории
local function updateCanvasSize(targetFrame: ScrollingFrame, targetLayout: UIListLayout)
    if not targetFrame or not targetLayout then return end

    task.wait(0.1) -- Небольшая задержка, чтобы UIListLayout успел обновиться
    local contentSize = targetLayout.AbsoluteContentSize
    targetFrame.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
end

-- Функция для фильтрации кнопок эмоций/анимаций на основе текста поиска для текущей активной панели
local function filterButtons(searchText: string)
    local lowerSearchText = searchText:lower()
    local targetButtons = nil
    local targetScrollingFrame = nil
    local targetUIListLayout = nil

    if currentCategory == "Emotes" then
        targetButtons = categoryData.Emotes.buttons
        targetScrollingFrame = categoryData.Emotes.scrollingFrame
        targetUIListLayout = categoryData.Emotes.uiListLayout
    elseif currentCategory == "Animations" then
        if currentSubCategory then
            -- Если выбрана подкатегория, фильтруем ее кнопки
            targetButtons = categoryData.Animations.subCategories[currentSubCategory].buttons
            targetScrollingFrame = categoryData.Animations.currentSubCategoryFrame
            targetUIListLayout = categoryData.Animations.currentSubCategoryLayout
        else
            -- Если нет подкатегории, фильтруем кнопки подкатегорий
            targetButtons = categoryData.Animations.buttons
            targetScrollingFrame = categoryData.Animations.scrollingFrame
            targetUIListLayout = categoryData.Animations.uiListLayout
        end
    end

    if not targetButtons then return end

    for name, button in pairs(targetButtons) do
        local buttonText = button.Text:lower()
        if string.find(buttonText, lowerSearchText) then
            button.Visible = true
        else
            button.Visible = false
        end
    end

    if targetScrollingFrame and targetUIListLayout then
        updateCanvasSize(targetScrollingFrame, targetUIListLayout)
    end
end

-- Функция для проверки, является ли данная анимация "камерой"
local function isCameraAnimation(animData: any)
    if type(animData) ~= "table" then return false end
    -- Проверяем, содержит ли таблица ключи, указывающие на анимацию камеры.
    -- Это может быть CameraRig или Camera, или KillerRig + CameraRig.
    if animData.CameraRig or animData.Camera then return true end
    -- Если это таблица с KillerRig, но без PlayerRig, это часто относится к катсценам/камере
    if animData.KillerRig and not animData.PlayerRig then return true end
    -- Дополнительно: если есть PlayerCFrameOffset, это тоже не прямая анимация для игрока
    if animData.PlayerCFrameOffset then return true end

    return false
end

-- Рекурсивная функция для создания кнопок анимаций из таблицы данных
-- В эту функцию передается имя "киллера" (например, "1x1x1x1")
local function createAnimationButtonsRecursive(parentFrame: ScrollingFrame, parentLayout: UIListLayout, animationTable: table, killerName: string)
    for animName, animValue in pairs(animationTable) do
        -- Игнорируем специфические поля из ваших модулей, которые не являются AssetID
        if animName == "IntroLighting" or animName == "OutroLighting" or animName == "IntroSky" then
            continue
        end

        if type(animValue) == "string" and string.find(animValue, "rbxassetid://") then
            -- Это прямая анимация (AssetID)
            local button = Instance.new("TextButton")
            button.Name = animName .. "Button"
            button.Parent = parentFrame
            button.Size = UDim2.new(1, -10, 0, 40)
            button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
            button.BorderColor3 = Color3.fromRGB(255, 255, 255)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
            button.Text = animName -- Отображаем имя анимации (например, "Idle", "Walk")
            button.Font = Enum.Font.SourceSansBold
            button.TextSize = 18

            button.MouseButton1Click:Connect(function()
                if humanoid and character then
                    -- Воспроизводим анимацию. Предполагаем, что нет SFX или SFXProperties для этих.
                    playLocalAnimation(humanoid, animValue, nil, nil, character)
                else
                    warn("DEBUG: Невозможно воспроизвести анимацию, гуманоид или персонаж равен nil.")
                end
            end)
            -- Добавляем кнопку в кэш подкатегории для фильтрации
            table.insert(categoryData.Animations.subCategories[killerName].buttons, button)
        elseif type(animValue) == "table" and not isCameraAnimation(animValue) then
            -- Это вложенная таблица, и это НЕ анимация камеры. Рекурсивно создаем кнопки для нее.
            -- Мы пропускаем создание отдельной кнопки для самой вложенной таблицы (например, "Stunned"),
            -- а создаем кнопки для ее дочерних элементов ("Start", "Loop", "End").
            createAnimationButtonsRecursive(parentFrame, parentLayout, animValue, killerName)
        end
    end
end


-- Функция для создания кнопок для основной категории (Emotes, Animations)
local function createCategoryButtons(categoryName: string, folder: Folder?)
    local currentCategoryData = categoryData[categoryName]
    if not currentCategoryData then return end

    -- Очищаем существующие кнопки и кэши для этой категории
    for _, button in pairs(currentCategoryData.buttons) do
        button:Destroy()
    end
    currentCategoryData.buttons = {}
    currentCategoryData.configs = {}
    currentCategoryData.buttonNameCache = {}

    if categoryName == "Emotes" then
        if not folder then
            warn("DEBUG: Emotes folder is nil. Skipping emote button creation.")
            return
        end
        for _, emoteConfigModule in pairs(folder:GetChildren()) do
            if emoteConfigModule:IsA("ModuleScript") then
                local success, emoteData = pcall(require, emoteConfigModule)
                if success and emoteData.AssetID then
                    local buttonText = emoteData.DisplayName or (type(emoteData.AssetID) == "string" and emoteData.AssetID or "Эмоция")

                    if currentCategoryData.buttonNameCache[buttonText] then
                        warn(string.format("DEBUG: Обнаружена дублирующая кнопка эмоции '%s' в категории '%s'. Пропускаем ее.", buttonText, categoryName))
                        continue
                    end

                    currentCategoryData.buttonNameCache[buttonText] = true

                    local button = Instance.new("TextButton")
                    button.Name = emoteConfigModule.Name .. "Button"
                    button.Parent = currentCategoryData.scrollingFrame
                    button.Size = UDim2.new(1, -10, 0, 40)
                    button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                    button.BorderColor3 = Color3.fromRGB(255, 255, 255)
                    button.TextColor3 = Color3.fromRGB(255, 255, 255)
                    button.Text = buttonText
                    button.Font = Enum.Font.SourceSansBold
                    button.TextSize = 18

                    button.MouseButton1Click:Connect(function()
                        if humanoid and character then
                            playLocalAnimation(humanoid, emoteData.AssetID, emoteData.SFX, emoteData.SFXProperties, character)
                        else
                            warn("DEBUG: Невозможно воспроизвести эмоцию, гуманоид или персонаж равен nil.")
                        end
                    end)

                    currentCategoryData.buttons[buttonText] = button
                    table.insert(currentCategoryData.configs, emoteData)
                else
                    warn("DEBUG: Не удалось загрузить модуль эмоции или отсутствует AssetID в папке '%s':", categoryName, emoteConfigModule.Name)
                end
            end
        end
        updateCanvasSize(currentCategoryData.scrollingFrame, currentCategoryData.uiListLayout)

    elseif categoryName == "Animations" then
        -- Для "Animations" мы теперь используем встроенные данные allKillerAnimations
        for killerName, killerData in pairs(allKillerAnimations) do
            -- Создаем данные для этой подкатегории (например, "1x1x1x1")
            currentCategoryData.subCategories[killerName] = {
                data = killerData, -- Хранит встроенные данные
                buttons = {}, -- Будут кнопки анимаций для этой подкатегории
                scrollingFrame = nil,
                uiListLayout = nil,
                buttonNameCache = {}
            }

            -- Создаем кнопку для подкатегории (например, "1x1x1x1")
            local subCategoryButton = Instance.new("TextButton")
            subCategoryButton.Name = killerName .. "SubCategoryButton"
            subCategoryButton.Parent = currentCategoryData.scrollingFrame
            subCategoryButton.Size = UDim2.new(1, -10, 0, 40)
            subCategoryButton.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
            subCategoryButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
            subCategoryButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            subCategoryButton.Text = killerName
            subCategoryButton.Font = Enum.Font.SourceSansBold
            subCategoryButton.TextSize = 18
            currentCategoryData.buttons[killerName] = subCategoryButton

            subCategoryButton.MouseButton1Click:Connect(function()
                -- Скрываем основной ScrollingFrame "Animations"
                currentCategoryData.scrollingFrame.Visible = false
                currentSubCategory = killerName

                -- Создаем или показываем ScrollingFrame для этой подкатегории
                local subCatFrame = currentCategoryData.subCategories[killerName].scrollingFrame
                local subCatLayout = currentCategoryData.subCategories[killerName].uiListLayout

                if not subCatFrame then
                    subCatFrame = Instance.new("ScrollingFrame")
                    subCatFrame.Name = killerName .. "AnimationsContainer"
                    subCatFrame.Parent = mainFrame
                    subCatFrame.Size = UDim2.new(1, 0, 1, -80)
                    subCatFrame.Position = UDim2.new(0, 0, 0, 80)
                    subCatFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
                    subCatFrame.BorderSizePixel = 0
                    subCatFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
                    subCatFrame.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
                    subCatFrame.Visible = true

                    subCatLayout = Instance.new("UIListLayout")
                    subCatLayout.Parent = subCatFrame
                    subCatLayout.Padding = UDim.new(0, 5)
                    subCatLayout.SortOrder = Enum.SortOrder.LayoutOrder

                    currentCategoryData.subCategories[killerName].scrollingFrame = subCatFrame
                    currentCategoryData.subCategories[killerName].uiListLayout = subCatLayout

                    -- Теперь создаем кнопки для анимаций внутри этого встроенного набора данных
                    if killerData.ZombieAnimations then
                        createAnimationButtonsRecursive(subCatFrame, subCatLayout, killerData.ZombieAnimations, killerName)
                    end
                    if killerData.Animations then
                        createAnimationButtonsRecursive(subCatFrame, subCatLayout, killerData.Animations, killerName)
                    end
                    if killerData.PizzaDeliveryAnimations then
                        createAnimationButtonsRecursive(subCatFrame, subCatLayout, killerData.PizzaDeliveryAnimations, killerName)
                    end
                    if killerData.VoidRush then
                        createAnimationButtonsRecursive(subCatFrame, subCatLayout, killerData.VoidRush, killerName)
                    end
                    for k, v in pairs(killerData) do
                        if type(v) == "string" and string.find(v, "rbxassetid://") and not isCameraAnimation(v) then
                             -- Создать кнопку для этой top-level анимации
                            local button = Instance.new("TextButton")
                            button.Name = k .. "Button"
                            button.Parent = subCatFrame
                            button.Size = UDim2.new(1, -10, 0, 40)
                            button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                            button.BorderColor3 = Color3.fromRGB(255, 255, 255)
                            button.TextColor3 = Color3.fromRGB(255, 255, 255)
                            button.Text = k
                            button.Font = Enum.Font.SourceSansBold
                            button.TextSize = 18
                            button.MouseButton1Click:Connect(function()
                                if humanoid and character then
                                    playLocalAnimation(humanoid, v, nil, nil, character)
                                else
                                    warn("DEBUG: Невозможно воспроизвести анимацию, гуманоид или персонаж равен nil.")
                                end
                            end)
                            table.insert(currentCategoryData.subCategories[killerName].buttons, button)
                        end
                    end


                else
                    subCatFrame.Visible = true
                end

                currentCategoryData.currentSubCategoryFrame = subCatFrame
                currentCategoryData.currentSubCategoryLayout = subCatLayout

                -- Обновляем размер холста для новой подкатегории
                updateCanvasSize(subCatFrame, subCatLayout)
                searchTextBox.Text = "" -- Сбрасываем поиск при смене подкатегории
                filterButtons("")
            end)
        end
        updateCanvasSize(currentCategoryData.scrollingFrame, currentCategoryData.uiListLayout)
    end
end

-- Функция для возврата из подкатегории к списку подкатегорий
local function backToSubCategories()
    local animData = categoryData.Animations
    if animData.currentSubCategoryFrame then
        animData.currentSubCategoryFrame.Visible = false
        animData.currentSubCategoryFrame = nil
        animData.currentSubCategoryLayout = nil
    end
    currentSubCategory = nil
    animData.scrollingFrame.Visible = true -- Показываем основной список подкатегорий
    searchTextBox.Text = ""
    filterButtons("")
    updateCanvasSize(animData.scrollingFrame, animData.uiListLayout)
end

-- Создаем кнопку "Назад" для подкатегорий
local backButton = Instance.new("TextButton")
backButton.Name = "BackButton"
backButton.Parent = mainFrame
backButton.Size = UDim2.new(0, 60, 0, 30)
backButton.Position = UDim2.new(0, 5, 0, 45) -- Слева от поиска
backButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
backButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
backButton.TextColor3 = Color3.fromRGB(255, 255, 255)
backButton.Text = "← Back"
backButton.Font = Enum.Font.SourceSansBold
backButton.TextSize = 14
backButton.ZIndex = 2
backButton.Visible = false -- Изначально скрыт

backButton.MouseButton1Click:Connect(backToSubCategories)


-- Функция для переключения активной категории
local function switchToCategory(newCategoryName: string)
    if currentCategory == newCategoryName and not currentSubCategory then return end

    -- Скрываем ScrollingFrame предыдущей категории
    local prevCategoryData = categoryData[currentCategory]
    if prevCategoryData and prevCategoryData.scrollingFrame then
        prevCategoryData.scrollingFrame.Visible = false
    end
    -- Если была открыта подкатегория, скрываем её
    if prevCategoryData and prevCategoryData.currentSubCategoryFrame then
        prevCategoryData.currentSubCategoryFrame.Visible = false
        prevCategoryData.currentSubCategoryFrame = nil
        prevCategoryData.currentSubCategoryLayout = nil
    end
    currentSubCategory = nil -- Сбрасываем подкатегорию при смене основной категории

    -- Показываем ScrollingFrame новой категории
    local newCategoryData = categoryData[newCategoryName]
    if newCategoryData and newCategoryData.scrollingFrame then
        newCategoryData.scrollingFrame.Visible = true
        currentCategory = newCategoryName

        -- Управляем видимостью кнопки "Назад"
        backButton.Visible = (newCategoryName == "Animations")

        -- Сбрасываем поиск и фильтр для новой категории
        searchTextBox.Text = ""
        filterButtons("")

        print("DEBUG: Переключено на категорию:", newCategoryName)
    else
        warn("DEBUG: Попытка переключиться на несуществующую или неинициализированную категорию:", newCategoryName)
    end
end


--- Настройка GUI и соединения ---

-- Создаем ScrollingFrame и UIListLayout для каждой основной категории
for catName, catData in pairs(categoryData) do
    local scrollingFrame = Instance.new("ScrollingFrame")
    scrollingFrame.Name = catName .. "Container"
    scrollingFrame.Parent = mainFrame
    scrollingFrame.Size = UDim2.new(1, 0, 1, -80) -- Скорректированная высота для кнопок категорий + поиска
    scrollingFrame.Position = UDim2.new(0, 0, 0, 80) -- Скорректированная позиция
    scrollingFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    scrollingFrame.BorderSizePixel = 0
    scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    scrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)
    scrollingFrame.Visible = false -- Изначально скрыт

    local uiListLayout = Instance.new("UIListLayout")
    uiListLayout.Parent = scrollingFrame
    uiListLayout.Padding = UDim.new(0, 5)
    uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder

    catData.scrollingFrame = scrollingFrame
    catData.uiListLayout = uiListLayout
end

-- Создаем кнопки выбора категорий
local categoryButtonNames = {"Emotes", "Animations"}
for i, catName in ipairs(categoryButtonNames) do
    local button = Instance.new("TextButton")
    button.Name = catName .. "Tab"
    button.Parent = categoryButtonsFrame
    button.Size = UDim2.new(1/#categoryButtonNames, -5, 1, -10) -- Распределяем по горизонтали с небольшим отступом
    button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    button.BorderColor3 = Color3.fromRGB(255, 255, 255)
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Text = catName
    button.Font = Enum.Font.SourceSansBold
    button.TextSize = 18
    button.LayoutOrder = i -- Обеспечиваем порядок с UIListLayout

    button.MouseButton1Click:Connect(function()
        switchToCategory(catName)
    end)
end

-- Функция для переключения видимости панели поиска и настройки макета
local function toggleSearchBar()
    local isVisible = searchTextBox.Visible
    searchTextBox.Visible = not isVisible

    local targetSf = nil
    local targetLayout = nil

    if currentCategory == "Emotes" then
        targetSf = categoryData.Emotes.scrollingFrame
        targetLayout = categoryData.Emotes.uiListLayout
    elseif currentCategory == "Animations" then
        if currentSubCategory then
            targetSf = categoryData.Animations.currentSubCategoryFrame
            targetLayout = categoryData.Animations.currentSubCategoryLayout
        else
            targetSf = categoryData.Animations.scrollingFrame
            targetLayout = categoryData.Animations.uiListLayout
        end
    end

    if not targetSf then return end

    if searchTextBox.Visible then
        searchTextBox:CaptureFocus()
        targetSf.Position = UDim2.new(0, 0, 0, 115) -- Перемещаем ScrollingFrame ниже для поиска
        targetSf.Size = UDim2.new(1, 0, 1, -115) -- Уменьшаем высоту
        searchTextBox.Text = ""
        filterButtons("")
    else
        searchTextBox:ReleaseFocus()
        targetSf.Position = UDim2.new(0, 0, 0, 80) -- Перемещаем ScrollingFrame обратно
        targetSf.Size = UDim2.new(1, 0, 1, -80) -- Восстанавливаем высоту
        filterButtons("")
    end
    updateCanvasSize(targetSf, targetLayout)
end

-- Функция для переключения видимости меню эмоций
local function toggleMenu()
    mainFrame.Visible = not mainFrame.Visible
    openButton.Text = mainFrame.Visible and "Close Menu" or "Open Menu"
    if mainFrame.Visible then
        -- При открытии меню убедимся, что показана категория по умолчанию
        switchToCategory("Emotes") -- Или любая другая по умолчанию
    else
        -- Если закрываем меню, также закрываем строку поиска
        if searchTextBox.Visible then
            toggleSearchBar()
        end
        -- Скрываем кнопку "Назад", если меню закрыто
        backButton.Visible = false
    end
end

-- Подключаем кнопку открытия
openButton.MouseButton1Click:Connect(toggleMenu)

-- Подключаем кнопку поиска
searchButton.MouseButton1Click:Connect(toggleSearchBar)

-- Подключаем событие .Changed текстового поля поиска
searchTextBox.Changed:Connect(function(property)
    if property == "Text" then
        filterButtons(searchTextBox.Text)
    end
end)

-- Подключаем событие .FocusLost текстового поля поиска (например, при нажатии Enter или клике в сторону)
searchTextBox.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        filterButtons(searchTextBox.Text)
    end
end)

-- Обработка обновлений персонажа игрока
local function setupHumanoidConnections(targetHumanoid: Humanoid)
end

local function handleCharacterSetup(newCharacter: Model)
    print("DEBUG: Персонаж загружен:", newCharacter.Name)
    local success, newHumanoid = pcall(function()
        return newCharacter:WaitForChild("Humanoid", 10)
    end)
    if success and newHumanoid then
        humanoid = newHumanoid
        originalJumpPower = humanoid.JumpPower or 50
        print("DEBUG: Гуманоид игрока найден для нового персонажа:", humanoid.Name)
        setupHumanoidConnections(humanoid)
        stopAllEmotes()
    else
        humanoid = nil
        warn("DEBUG: Гуманоид не найден в новой модели персонажа:", newCharacter.Name, "после 10 секунд.")
    end
end

-- Слушаем изменения персонажа
player.CharacterAdded:Connect(function(char)
    character = char
    handleCharacterSetup(char)
end)

if player.Character then
    character = player.Character
    handleCharacterSetup(character)
end

-- Останавливаем все эмоции при нажатии Пробела и отключаем прыжок
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end

    if input.KeyCode == Enum.KeyCode.Space then
        stopAllEmotes()

        if humanoid then
            originalJumpPower = humanoid.JumpPower or 50
            humanoid.JumpPower = 0
            humanoid.Jump = false
        end
    elseif input.UserInputType == Enum.UserInputType.Gamepad1 and input.KeyCode == Enum.KeyCode.ButtonA then
        stopAllEmotes()
    elseif input.UserInputType == Enum.UserInputType.Touch then
        stopAllEmotes()
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end

    if input.KeyCode == Enum.KeyCode.Space then
        if humanoid then
            humanoid.JumpPower = originalJumpPower
        end
    end
end)

-- Начальное заполнение кнопок эмоций для всех категорий
-- Folder для Emotes передаем, для Animations - nil, т.к. данные встроены
createCategoryButtons("Emotes", emotesFolder)
createCategoryButtons("Animations", nil) -- Передаем nil, т.к. данные уже в скрипте

-- Устанавливаем начальную видимую категорию
switchToCategory("Emotes")

print("DEBUG: Скрипт эмоций успешно загружен с категориями и встроенными анимациями.")
]]

-- === ОБРАБОТКА КНОПКИ ПОДТВЕРЖДЕНИЯ КЛЮЧА ===
submitButton.MouseButton1Click:Connect(function()
	local inputKey = textBox.Text
	if inputKey == validKey then
		keyGui:Destroy()

		local success, err = pcall(function()
			loadstring(lexioiScript)()
		end)

		if not success then
			warn("Ошибка при запуске скрипта Lexioi: " .. tostring(err))
		end
	else
		textBox.Text = "Invalid key!"
	end
end)
