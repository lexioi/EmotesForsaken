-- Script by lexioi (Modified with Search and Duplicate Button Check)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

-- Player and Character Variables (will be set dynamically)
local player = Players.LocalPlayer
print("DEBUG: LocalPlayer:", player.Name)

local character: Model? = nil
local humanoid: Humanoid? = nil
local originalJumpPower = 50

-- Assets
local assetsFolder = ReplicatedStorage:WaitForChild("Assets")
local emotesFolder = assetsFolder:WaitForChild("Emotes")

-- State Management
-- Store active animation tracks and sounds for the LOCAL player's humanoid only.
local activeEmotes: {[Humanoid]: {animationTrack: AnimationTrack?, sound: Sound?, stoppedConnection: RBXScriptConnection?}} = {}
local isMovementDisabled: boolean = false

-- GUI Creation
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "EmoteGui"
screenGui.Parent = player:WaitForChild("PlayerGui")
screenGui.ResetOnSpawn = false

local openButton = Instance.new("TextButton")
openButton.Name = "OpenButton"
openButton.Parent = screenGui
openButton.Size = UDim2.new(0, 150, 0, 50)
openButton.Position = UDim2.new(0.5, -75, 0.8, 0)
openButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
openButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
openButton.TextColor3 = Color3.fromRGB(255, 255, 255)
openButton.Text = "Open Emotes"
openButton.Font = Enum.Font.SourceSansBold
openButton.TextSize = 20
openButton.Active = true
openButton.Draggable = true

local mainFrame = Instance.new("Frame")
mainFrame.Name = "EmoteMenu"
mainFrame.Parent = screenGui
mainFrame.Size = UDim2.new(0, 400, 0, 300)
mainFrame.Position = UDim2.new(0.5, -200, 0.5, -150)
mainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
mainFrame.BorderColor3 = Color3.fromRGB(255, 255, 255)
mainFrame.Visible = false
mainFrame.Active = true
mainFrame.Draggable = true

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.Parent = mainFrame
titleLabel.Size = UDim2.new(1, 0, 0, 40)
titleLabel.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.Text = "Emotes"
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextSize = 24

-- Search elements
local searchButton = Instance.new("TextButton")
searchButton.Name = "SearchButton"
searchButton.Parent = mainFrame
searchButton.Size = UDim2.new(0, 30, 0, 30)
searchButton.Position = UDim2.new(1, -35, 0, 5) -- Top right of mainFrame, slightly offset
searchButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
searchButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
searchButton.TextColor3 = Color3.fromRGB(255, 255, 255)
searchButton.Text = "üîç" -- –õ—É–ø–∞
searchButton.Font = Enum.Font.SourceSansBold
searchButton.TextSize = 20
searchButton.ZIndex = 2 -- Make sure it's above other elements

local searchTextBox = Instance.new("TextBox")
searchTextBox.Name = "SearchTextBox"
searchTextBox.Parent = mainFrame
searchTextBox.Size = UDim2.new(1, -40, 0, 30) -- Adjust size to fit next to search button
searchTextBox.Position = UDim2.new(0, 5, 0, 45) -- Below title, offset from left
searchTextBox.PlaceholderText = "Search emotes..."
searchTextBox.TextScaled = true
searchTextBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
searchTextBox.BorderColor3 = Color3.fromRGB(255, 255, 255)
searchTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
searchTextBox.Visible = false
searchTextBox.ClearTextOnFocus = false
searchTextBox.ZIndex = 2

local scrollingFrame = Instance.new("ScrollingFrame")
scrollingFrame.Name = "Container"
scrollingFrame.Parent = mainFrame
scrollingFrame.Size = UDim2.new(1, 0, 1, -40) -- Initial size, adjusted when search is active
scrollingFrame.Position = UDim2.new(0, 0, 0, 40)
scrollingFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
scrollingFrame.BorderSizePixel = 0
scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(255, 255, 255)

local uiListLayout = Instance.new("UIListLayout")
uiListLayout.Parent = scrollingFrame
uiListLayout.Padding = UDim.new(0, 5)
uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder

-- Store all loaded emote configurations for searching
local allEmoteConfigs = {}
local emoteButtons = {} -- Store references to created buttons for easy access/filtering

-- Function to reset player movement to default
local function resetPlayerMovement()
    if humanoid and isMovementDisabled then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = originalJumpPower
        isMovementDisabled = false
    end
end

-- Function to stop a specific emote for a given humanoid (only used for local player now)
local function stopEmoteForHumanoid(targetHumanoid: Humanoid)
    local emoteData = activeEmotes[targetHumanoid]
    if emoteData then
        if emoteData.animationTrack then
            emoteData.animationTrack:Stop()
            if emoteData.stoppedConnection then
                emoteData.stoppedConnection:Disconnect()
                emoteData.stoppedConnection = nil
            end
        end
        if emoteData.sound then
            emoteData.sound:Stop()
            emoteData.sound:Destroy() -- Clean up the sound instance
        end
        activeEmotes[targetHumanoid] = nil
    end
end

-- Function to stop all currently playing emotes and reset player state
local function stopAllEmotes()
    -- –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —ç–º–æ—Ü–∏–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ humanoid
    if humanoid then
        stopEmoteForHumanoid(humanoid) 
    end
    activeEmotes = {}
    resetPlayerMovement()
end

-- Local function to play animation (client-side only for instant feedback)
local function playLocalAnimation(targetHumanoid: Humanoid, emoteConfig: {AssetID: any, DisplayName: string?, SFX: any, SFXProperties: {Looped: boolean?}, SyncMusic: boolean?, SyncAnim: boolean?}, characterModel: Model)
    -- –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª—é–±—É—é –∞–∫—Ç–∏–≤–Ω—É—é —ç–º–æ—Ü–∏—é –Ω–∞ —ç—Ç–æ–º –≥—É–º–∞–Ω–æ–∏–¥–µ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –Ω–æ–≤–æ–π
    stopEmoteForHumanoid(targetHumanoid)

    local animationIdToPlay: string
    if type(emoteConfig.AssetID) == "table" then
        -- If AssetID is a table, pick a random one
        if #emoteConfig.AssetID > 0 then
            animationIdToPlay = emoteConfig.AssetID[math.random(1, #emoteConfig.AssetID)]
            print("DEBUG: Randomly selected AnimationId (from table):", animationIdToPlay)
        else
            warn("DEBUG: emoteConfig.AssetID is an empty table. Cannot play animation.")
            return -- Exit if no animation IDs are provided
        end
    elseif type(emoteConfig.AssetID) == "string" then
        animationIdToPlay = emoteConfig.AssetID
        print("DEBUG: Using AnimationId (from string):", animationIdToPlay)
    else
        warn("DEBUG: Invalid type for emoteConfig.AssetID. Expected string or table, got", type(emoteConfig.AssetID))
        return -- Exit if AssetID is neither string nor table
    end

    local animation = Instance.new("Animation")
    animation.AnimationId = animationIdToPlay
    local animationTrack = targetHumanoid:LoadAnimation(animation)
    animationTrack:Play()
    ------------------------------------------------------------------

    -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –∞–∫—Ç–∏–≤–Ω–æ–π —ç–º–æ—Ü–∏–∏ –¥–ª—è —ç—Ç–æ–≥–æ –≥—É–º–∞–Ω–æ–∏–¥–∞ (–ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞)
    activeEmotes[targetHumanoid] = {animationTrack = animationTrack}

    -- --- –î–ê–õ–ï–ï –ò–î–ï–¢ –¢–û–õ–¨–ö–û –õ–û–ì–ò–ö–ê –î–õ–Ø –ó–í–£–ö–ê, –∫–æ—Ç–æ—Ä–∞—è –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç –∞–Ω–∏–º–∞—Ü–∏—é ---
    local soundAttachmentPart = nil
    -- –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —á–∞—Å—Ç—å –¥–ª—è –∑–≤—É–∫–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ SFX —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ characterModel –¥–æ—Å—Ç—É–ø–µ–Ω
    if emoteConfig.SFX and characterModel then
        print("DEBUG: Attempting to find sound attachment part for characterModel:", characterModel.Name)
        
        local chosenSfxId: string
        if type(emoteConfig.SFX) == "table" then
            if #emoteConfig.SFX > 0 then
                chosenSfxId = emoteConfig.SFX[math.random(1, #emoteConfig.SFX)]
                print("DEBUG: Randomly selected SFXId (from table):", chosenSfxId)
            else
                warn("DEBUG: emoteConfig.SFX is an empty table. Sound will not play.")
            end
        elseif type(emoteConfig.SFX) == "string" then
            chosenSfxId = emoteConfig.SFX
            print("DEBUG: Using SFXId (from string):", chosenSfxId)
        else
            warn("DEBUG: Invalid type for emoteConfig.SFX. Expected string or table, got", type(emoteConfig.SFX))
        end

        if chosenSfxId then -- Only proceed if a valid SFX ID was found
            -- –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ HumanoidRootPart —Å —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–º —Ç–∞–π–º–∞—É—Ç–æ–º
            -- –ò—Å–ø–æ–ª—å–∑—É–µ–º pcall, —á—Ç–æ–±—ã –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å –æ—à–∏–±–∫—É, –µ—Å–ª–∏ WaitForChild –∑–∞–≤–∏—Å–Ω–µ—Ç –∏–ª–∏ –≤–µ—Ä–Ω–µ—Ç nil
            local success, rootPartResult = pcall(function() 
                return characterModel:WaitForChild("HumanoidRootPart", 10) 
            end)
            
            if success and rootPartResult then
                soundAttachmentPart = rootPartResult
                print("DEBUG: Successfully found HumanoidRootPart for", characterModel.Name)
            else
                warn(string.format("DEBUG: HumanoidRootPart NOT found for model '%s' within 10 seconds! Attempting alternative (UpperTorso/Torso). For emote '%s'", characterModel.Name, emoteConfig.DisplayName or tostring(emoteConfig.AssetID)))
                -- –ï—Å–ª–∏ HumanoidRootPart –Ω–µ –Ω–∞–π–¥–µ–Ω –∑–∞ 10 —Å–µ–∫—É–Ω–¥, –ø—Ä–æ–±—É–µ–º UpperTorso, –∑–∞—Ç–µ–º Torso
                soundAttachmentPart = characterModel:FindFirstChild("UpperTorso") or characterModel:FindFirstChild("Torso")
                if soundAttachmentPart then
                    print(string.format("DEBUG: Successfully found alternative sound attachment part (%s) for %s.", soundAttachmentPart.Name, characterModel.Name))
                else
                    warn(string.format("DEBUG: Neither HumanoidRootPart, UpperTorso, nor Torso found for model '%s'! Sound will not play for emote '%s'", characterModel.Name, emoteConfig.DisplayName or tostring(emoteConfig.AssetID)))
                end
            end
        end
        
        if chosenSfxId and soundAttachmentPart then
            local sound = Instance.new("Sound")
            sound.SoundId = chosenSfxId
            sound.Parent = soundAttachmentPart
            if emoteConfig.SFXProperties and emoteConfig.SFXProperties.Looped then
                sound.Looped = true
                -- Connect the sound's Stopped event to the animation's Stopped event
                -- This ensures the sound stops when the animation stops, especially if looped
                local soundStoppedConnection
                soundStoppedConnection = animationTrack.Stopped:Connect(function()
                    if sound and sound.IsPlaying then
                        sound:Stop()
                    end
                    if soundStoppedConnection then
                        soundStoppedConnection:Disconnect()
                    end
                end)
            end
            sound:Play()
            activeEmotes[targetHumanoid].sound = sound
        elseif chosenSfxId then
            warn(string.format("DEBUG: Sound for emote '%s' could not be played because no valid attachment part was found.", emoteConfig.DisplayName or tostring(emoteConfig.AssetID)))
        end
    elseif emoteConfig.SFX and not characterModel then
        warn("DEBUG: characterModel is NIL when trying to play sound for emote:", emoteConfig.DisplayName or tostring(emoteConfig.AssetID))
    end
    -------------------------------------------------------------------

    -- –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Å–æ–±—ã—Ç–∏—é 'Stopped' –∞–Ω–∏–º–∞—Ü–∏–∏, —á—Ç–æ–±—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —ç–º–æ—Ü–∏—é
    activeEmotes[targetHumanoid].stoppedConnection = animationTrack.Stopped:Connect(function()
        task.wait() -- –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞, —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ —ç—Ç–æ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∏ —Ä—É—á–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
        if activeEmotes[targetHumanoid] and activeEmotes[targetHumanoid].animationTrack == animationTrack then
            stopEmoteForHumanoid(targetHumanoid)
        end
    end)
end

-- Function to update the scrolling frame's CanvasSize
local function updateCanvasSize()
    task.wait(0.1) -- Small delay to allow UIListLayout to update
    local contentSize = uiListLayout.AbsoluteContentSize
    scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, contentSize.Y + 10)
end

-- Function to filter emote buttons based on search text
local function filterEmoteButtons(searchText: string)
    local lowerSearchText = searchText:lower()
    for name, button in pairs(emoteButtons) do
        local emoteName = button.Text:lower()
        if string.find(emoteName, lowerSearchText) then
            button.Visible = true
        else
            button.Visible = false
        end
    end
    updateCanvasSize() -- Re-calculate canvas size after filtering
end

-- Function to create buttons for all available emotes
local function createEmoteButtons()
    local existingButtonNames = {} -- To track names and prevent duplicates

    for _, emoteConfigModule in pairs(emotesFolder:GetChildren()) do
        if emoteConfigModule:IsA("ModuleScript") then
            local success, emoteData = pcall(require, emoteConfigModule)
            if success and emoteData.AssetID then
                local buttonText = emoteData.DisplayName or (type(emoteData.AssetID) == "string" and emoteData.AssetID or "Emote")
                
                -- Check for duplicate button names
                if existingButtonNames[buttonText] then
                    warn(string.format("DEBUG: Duplicate emote button found for '%s'. Skipping this one.", buttonText))
                    continue -- Skip creating this button
                end
                
                existingButtonNames[buttonText] = true -- Mark this name as used

                local button = Instance.new("TextButton")
                button.Name = emoteConfigModule.Name .. "Button"
                button.Parent = scrollingFrame
                button.Size = UDim2.new(1, -10, 0, 40)
                button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                button.BorderColor3 = Color3.fromRGB(255, 255, 255)
                button.TextColor3 = Color3.fromRGB(255, 255, 255)
                button.Text = buttonText
                button.Font = Enum.Font.SourceSansBold
                button.TextSize = 18

                button.MouseButton1Click:Connect(function()
                    if humanoid and character then
                        playLocalAnimation(humanoid, emoteData, character)
                    else
                        warn("DEBUG: Cannot play emote, humanoid or character is nil.")
                    end
                end)
                
                emoteButtons[buttonText] = button -- Store the button reference
                table.insert(allEmoteConfigs, emoteData) -- Store config for search
            else
                warn("DEBUG: Failed to require emote module or AssetID is missing:", emoteConfigModule.Name)
            end
        end
    end

    updateCanvasSize() -- Initial canvas size calculation
end

-- Function to toggle the search bar visibility and adjust layout
local function toggleSearchBar()
    local isVisible = searchTextBox.Visible
    searchTextBox.Visible = not isVisible

    if searchTextBox.Visible then
        searchTextBox:CaptureFocus() -- Focus on the text box when it appears
        scrollingFrame.Position = UDim2.new(0, 0, 0, 80) -- Move scrolling frame down
        scrollingFrame.Size = UDim2.new(1, 0, 1, -80) -- Reduce height
        searchTextBox.Text = "" -- Clear previous search
        filterEmoteButtons("") -- Show all emotes
    else
        searchTextBox:ReleaseFocus() -- Release focus when it disappears
        scrollingFrame.Position = UDim2.new(0, 0, 0, 40) -- Move scrolling frame back up
        scrollingFrame.Size = UDim2.new(1, 0, 1, -40) -- Restore height
        filterEmoteButtons("") -- Show all emotes when closing search
    end
    updateCanvasSize()
end

-- Function to toggle emote menu visibility
local function toggleMenu()
    mainFrame.Visible = not mainFrame.Visible
    openButton.Text = mainFrame.Visible and "Close Emotes" or "Open Emotes"
    if not mainFrame.Visible then
        -- If closing the menu, also close the search bar
        if searchTextBox.Visible then
            toggleSearchBar()
        end
    end
end

-- Connect open button
openButton.MouseButton1Click:Connect(toggleMenu)

-- Connect search button
searchButton.MouseButton1Click:Connect(toggleSearchBar)

-- Connect search text box .Changed event
searchTextBox.Changed:Connect(function(property)
    if property == "Text" then
        filterEmoteButtons(searchTextBox.Text)
    end
end)

-- Connect search text box .FocusLost event (e.g., when pressing Enter or clicking away)
searchTextBox.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        filterEmoteButtons(searchTextBox.Text)
    end
end)

-- Handle player character updates
local function setupHumanoidConnections(targetHumanoid: Humanoid)
    -- Place any humanoid-specific connections here if needed
end

local function handleCharacterSetup(newCharacter: Model)
    print("DEBUG: Character loaded:", newCharacter.Name)
    local success, newHumanoid = pcall(function()
        return newCharacter:WaitForChild("Humanoid", 10)
    end)
    if success and newHumanoid then
        humanoid = newHumanoid
        originalJumpPower = humanoid.JumpPower or 50
        print("DEBUG: Player Humanoid found for new character:", humanoid.Name)
        setupHumanoidConnections(humanoid)
        stopAllEmotes()
    else
        humanoid = nil
        warn("DEBUG: Humanoid not found in new character model:", newCharacter.Name, "after 10 seconds.")
    end
end

-- Listen for character changes
player.CharacterAdded:Connect(function(char)
    character = char
    handleCharacterSetup(char)
end)

if player.Character then
    character = player.Character
    handleCharacterSetup(character)
end

-- Stop all emotes on Spacebar press and disable jump
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end

    if input.KeyCode == Enum.KeyCode.Space then
        stopAllEmotes()

        if humanoid then
            originalJumpPower = humanoid.JumpPower or 50
            humanoid.JumpPower = 0
            humanoid.Jump = false
        end
    elseif input.UserInputType == Enum.UserInputType.Gamepad1 and input.KeyCode == Enum.KeyCode.ButtonA then
        stopAllEmotes()
    elseif input.UserInputType == Enum.UserInputType.Touch then
        stopAllEmotes()
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end

    if input.KeyCode == Enum.KeyCode.Space then
        if humanoid then
            humanoid.JumpPower = originalJumpPower
        end
    end
end)

-- Initialize emote buttons
createEmoteButtons()

print("DEBUG: Emote script loaded successfully.")
